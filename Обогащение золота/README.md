## Восстановление золота из руды

[HTML](https://github.com/fromufawithlove/Portfolio/blob/main/%D0%9E%D0%B1%D0%BE%D0%B3%D0%B0%D1%89%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B7%D0%BE%D0%BB%D0%BE%D1%82%D0%B0/AuCleaner.html) [ipynb](https://github.com/fromufawithlove/Portfolio/blob/main/%D0%9E%D0%B1%D0%BE%D0%B3%D0%B0%D1%89%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B7%D0%BE%D0%BB%D0%BE%D1%82%D0%B0/AuCleaner.ipynb)

### Описание проекта  
Во флотационную установку подаётся смесь золотосодержащей руды. После обогащения получается черновой концентрат и «отвальные хвосты», то есть остатки продукта с низкой концентрацией ценных металлов.
На стабильность этого процесса влияет непостоянное и неоптимальное физико-химическое состояние флотационной пульпы (смеси твёрдых частиц и жидкости).

Подготовьте прототип модели машинного обучения. Модель должна предсказать коэффициент восстановления золота из золотосодержащей руды. Используйте данные с параметрами добычи и очистки.

Модель поможет оптимизировать производство, чтобы не запускать предприятие с убыточными характеристиками.


### Выводы

Анализ данных:

- Концентрация золота растет после всех этапов очистки.
- Концентрация серебра значительно падает - возможно серебро попадает в хвосты.
- Концентрация свинца растет. Обогащение соединений свинца возможна из-за растворения части золота в свинце. Подробнее о процессе обогащения [тут](https://top-technologies.ru/ru/article/view?id=22441)
- Есть нулевые показатели концентрации у всех металлов на всех этапах очистки
- Распределение размера гранул совпадает на тестовой и обучающей выборках.
- Общая финальная концентрация металлов после всех этапов очистки растет.
- В ходе анализа данных избавились от выбросов (значений концентрации металлов < 0.5)

Модель:

- Написана функция вычисления итоговой sMAPE
- Обучено несколько моделей, вычислили для каждой из них sMAPE
- Оценено качество моделей на тестовых данных
- Лучший показатель sMAPE показала модельу модели Случайного леса с параметрами max_depth = 4, n_estimators = 30. Значение sMAPE: 7.32
- Проверка константной моделью DummyRegressor показала, что наша найденная модель работает лучше
